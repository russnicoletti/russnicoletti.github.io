initSidebarItems({"macro":[["__hyper__deref!",""],["__hyper__tm!",""],["__hyper_generate_header_serialization!",""],["bench_header!",""],["header!",""],["test_header!",""]],"mod":[["client","HTTP ClientUsageThe `Client` API is designed for most people to make HTTP requests. It utilizes the lower level `Request` API.GETThe returned value is a `Response`, which provides easy access to the `status`, the `headers`, and the response body via the `Read` trait.POSTSyncThe `Client` implements `Sync`, so you can share it among multiple threads and make multiple requests simultaneously."],["error","Error and Result module."],["header","Headers container, and common header fields.hyper has the opinion that Headers should be strongly-typed, because that's why we're using Rust in the first place. To set or get any header, an object must implement the `Header` trait from this module. Several common headers are already provided, such as `Host`, `ContentType`, `UserAgent`, and others.Why Typed?Or, why not stringly-typed? Types give the following advantages:More difficult to typo, since typos in types should be caught by the compiler Parsing to a proper type by default Defining Custom HeadersHyper provides many of the most commonly used headers in HTTP. If you need to define a custom header, it's easy to do while still taking advantage of the type system. Hyper includes a `header!` macro for defining many wrapper-style headers.This works well for simple \"string\" headers. But the header system actually involves 2 parts: parsing, and formatting. If you need to customize either part, you can do so.`Header` and `HeaderFormat`Consider a Do Not Track header. It can be true or false, but it represents that via the numerals `1` and `0`."],["http","Pieces pertaining to the HTTP message protocol."],["method","The HTTP request method"],["mime","Re-exporting the mime crate, for convenience."],["net","A collection of traits abstracting over Listeners and Streams."],["server","HTTP ServerServerA `Server` is created to listen on port, parse HTTP requests, and hand them off to a `Handler`. By default, the Server will listen across multiple threads, but that can be configured to a single thread if preferred.Handling requestsYou must pass a `Handler` to the Server that will handle requests. There is a default implementation for `fn`s and closures, allowing you pass one of those easily.As with any trait, you can also define a struct and implement `Handler` directly on your own type, and pass that to the `Server` instead.Since the `Server` will be listening on multiple threads, the `Handler` must implement `Sync`: any mutable state must be synchronized.The `Request` and `Response` pairA `Handler` receives a pair of arguments, a `Request` and a `Response`. The `Request` includes access to the `method`, `uri`, and `headers` of the incoming HTTP request. It also implements `std::io::Read`, in order to read any body, such as with `POST` or `PUT` messages.Likewise, the `Response` includes ways to set the `status` and `headers`, and implements `std::io::Write` to allow writing the response body.An aside: Write StatusThe `Response` uses a phantom type parameter to determine its write status. What does that mean? In short, it ensures you never write a body before adding all headers, and never add a header after writing some of the body.This is often done in most implementations by include a boolean property on the response, such as `headers_written`, checking that each time the body has something to write, so as to make sure the headers are sent once, and only once. But this has 2 downsides:You are typically never notified that your late header is doing nothing. There's a runtime cost to checking on every write. Instead, hyper handles this statically, or at compile-time. A `Response<Fresh>` includes a `headers_mut()` method, allowing you add more headers. It also does not implement `Write`, so you can't accidentally write early. Once the \"head\" of the response is correct, you can \"send\" it out by calling `start` on the `Response<Fresh>`. This will return a new `Response<Streaming>` object, that no longer has `headers_mut()`, but does implement `Write`."],["status","HTTP status codes"],["uri","HTTP RequestUris"],["version","HTTP Versions enumInstead of relying on typo-prone Strings, use expected HTTP versions as the `HttpVersion` enum."]],"struct":[["LanguageTag","A language tag as described in BCP47.Language tags are used to help identify languages, whether spoken, written, signed, or otherwise signaled, for the purpose of communication.  This includes constructed and artificial languages but excludes languages not intended primarily for human communication, such as programming languages."],["Url","The parsed representation of an absolute URL."]]});