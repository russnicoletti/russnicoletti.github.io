initSidebarItems({"struct":[["AcAutomaton","An Aho-Corasick finite automaton.The type parameter `P` is the type of the pattern that was used to construct this AcAutomaton."],["Dense","State transitions that can be stored either sparsely or densely.This uses less space but at the expense of slower matching."],["FullAcAutomaton","A complete Aho-Corasick automaton.This uses a single transition matrix that permits each input character to move to the next state with a single lookup in the matrix.This is as fast as it gets, but it is guaranteed to use a lot of memory. Namely, it will use at least `4 * 256 * #states`, where the number of states is capped at length of all patterns concatenated."],["Match","Records a match in the search text."],["Matches","An iterator of non-overlapping matches for in-memory text.This iterator yields `Match` values.`'a` is the lifetime of the automaton, `'s` is the lifetime of the search text, and `P` is the type of the Automaton's pattern."],["MatchesOverlapping","An iterator of overlapping matches for in-memory text.This iterator yields `Match` values.`'a` is the lifetime of the automaton, `'s` is the lifetime of the search text, and `P` is the type of the Automaton's pattern."],["Sparse","State transitions that are always sparse.This can use enormous amounts of memory when there are many patterns, but matching is very fast."],["StreamMatches","An iterator of non-overlapping matches for streaming text.This iterator yields `io::Result<Match>` values.`'a` is the lifetime of the automaton, `R` is the type of the underlying `io::Read`er, and P is the type of the Automaton's pattern."],["StreamMatchesOverlapping","An iterator of overlapping matches for streaming text.This iterator yields `io::Result<Match>` values.`'a` is the lifetime of the automaton, `R` is the type of the underlying `io::Read`er, and P is the type of the Automaton's pattern."]],"trait":[["Automaton","An abstraction over automatons and their corresponding iterators. The type parameter `P` is the type of the pattern that was used to construct this Automaton."],["Transitions","An abstraction over state transition strategies.This is an attempt to let the caller choose the space/time trade offs used for state transitions.(It's possible that this interface is merely good enough for just the two implementations in this crate.)"]],"type":[["StateIdx","The integer type used for the state index.Limiting this to 32 bit integers can have a big impact on memory usage when using the `Sparse` transition representation."]]});