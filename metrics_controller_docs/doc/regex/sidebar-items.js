initSidebarItems({"enum":[["Error","An error that occurred during parsing or compiling a regular expression."]],"fn":[["is_match","Tests if the given regular expression matches somewhere in the text given.If there was a problem compiling the regular expression, an error is returned.To find submatches, split or replace text, you'll need to compile an expression first."],["quote","Escapes all regular expression meta characters in `text`.The string returned may be safely used as a literal in a regular expression."]],"mod":[["bytes","Match regular expressions on arbitrary bytes.This module provides a nearly identical API to the one found in the top-level of this crate. There are two important differences:Matching is done on `&[u8]` instead of `&str`. Additionally, `Vec<u8>` is used where `String` would have been used. Regular expressions are compiled with Unicode support *disabled* by default. This means that while Unicode regular expressions can only match valid UTF-8, regular expressions in this module can match arbitrary bytes. Unicode support can be selectively enabled via the `u` flag in regular expressions provided by this sub-module. Example: match null terminated stringThis shows how to find all null-terminated strings in a slice of bytes:Example: selectively enable Unicode supportThis shows how to match an arbitrary byte pattern followed by a UTF-8 encoded string (e.g., to extract a title from a Matroska file):In general, if the Unicode flag is enabled in a capture group and that capture is part of the overall match, then the capture is *guaranteed* to be valid UTF-8.SyntaxThe supported syntax is pretty much the same as the syntax for Unicode regular expressions with a few changes that make sense for matching arbitrary bytes:A new flag, `u`, is available for switching to Unicode mode. By default, `u` is disabled, which roughly corresponds to \"ASCII compatible\" mode. In ASCII compatible mode, neither Unicode codepoints nor Unicode character classes are allowed. In ASCII compatible mode, Perl character classes (`\\w`, `\\d` and `\\s`) revert to their typical ASCII definition. `\\w` maps to `[[:word:]]`, `\\d` maps to `[[:digit:]]` and `\\s` maps to `[[:space:]]`. In ASCII compatible mode, word boundaries use the ASCII compatible `\\w` to determine whether a byte is a word byte or not. Hexadecimal notation can be used to specify arbitrary bytes instead of Unicode codepoints. For example, in ASCII compatible mode, `\\xFF` matches the literal byte `\\xFF`, while in Unicode mode, `\\xFF` is a Unicode codepoint that matches its UTF-8 encoding of `\\xC3\\xBF`. Similarly for octal notation. `.` matches any *byte* except for `\\n` instead of any codepoint. When the `s` flag is enabled, `.` matches any byte. PerformanceIn general, one should expect performance on `&[u8]` to be roughly similar to performance on `&str`."]],"struct":[["CaptureNames","An iterator over the names of all possible captures.`None` indicates an unnamed capture; the first element (capture 0, the whole matched region) is always unnamed.`'r` is the lifetime of the compiled regular expression."],["Captures","Captures represents a group of captured strings for a single match.The 0th capture always corresponds to the entire match. Each subsequent index corresponds to the next capture group in the regex. If a capture group is named, then the matched string is *also* available via the `name` method. (Note that the 0th capture is always unnamed and so must be accessed with the `at` method.)Positions returned from a capture group are always byte indices.`'t` is the lifetime of the matched text."],["FindCaptures","An iterator that yields all non-overlapping capture groups matching a particular regular expression.The iterator stops when no more matches can be found.`'r` is the lifetime of the compiled regular expression and `'t` is the lifetime of the matched string."],["FindMatches","An iterator over all non-overlapping matches for a particular string.The iterator yields a tuple of integers corresponding to the start and end of the match. The indices are byte offsets. The iterator stops when no more matches can be found.`'r` is the lifetime of the compiled regular expression and `'t` is the lifetime of the matched string."],["NoExpand","NoExpand indicates literal string replacement.It can be used with `replace` and `replace_all` to do a literal string replacement without expanding `$name` to their corresponding capture groups.`'t` is the lifetime of the literal text."],["Regex","A compiled regular expression for matching Unicode strings.It is represented as either a sequence of bytecode instructions (dynamic) or as a specialized Rust function (native). It can be used to search, split or replace text. All searching is done with an implicit `.*?` at the beginning and end of an expression. To force an expression to match the whole string (or a prefix or a suffix), you must use an anchor like `^` or `$` (or `\\A` and `\\z`).While this crate will handle Unicode strings (whether in the regular expression or in the search text), all positions returned are **byte indices**. Every byte index is guaranteed to be at a Unicode code point boundary.The lifetimes `'r` and `'t` in this crate correspond to the lifetime of a compiled regular expression and text to search, respectively.The only methods that allocate new strings are the string replacement methods. All other methods (searching and splitting) return borrowed pointers into the string given.ExamplesFind the location of a US phone number:Using the `std::str::StrExt` methods with `Regex`**Note**: This section requires that this crate is currently compiled with           the `pattern` Cargo feature enabled.Since `Regex` implements `Pattern`, you can use regexes with methods defined on `std::str::StrExt`. For example, `is_match`, `find`, `find_iter` and `split` can be replaced with `StrExt::contains`, `StrExt::find`, `StrExt::match_indices` and `StrExt::split`.Here are some examples:"],["RegexSet","Match multiple (possibly overlapping) regular expressions in a single scan.A regex set corresponds to the union of two or more regular expressions. That is, a regex set will match text where at least one of its constituent regular expressions matches. A regex set as its formulated here provides a touch more power: it will also report *which* regular expressions in the set match. Indeed, this is the key difference between regex sets and a single `Regex` with many alternates, since only one alternate can match at a time.For example, consider regular expressions to match email addresses and domains: `[a-z]+@[a-z]+.(com|org|net)` and `[a-z]+.(com|org|net)`. If a regex set is constructed from those regexes, then searching the text `foo@example.com` will report both regexes as matching. Of course, one could accomplish this by compiling each regex on its own and doing two searches over the text. The key advantage of using a regex set is that it will report the matching regexes using a *single pass through the text*. If one has hundreds or thousands of regexes to match repeatedly (like a URL router for a complex web application or a user agent matcher), then a regex set can realize huge performance gains.ExampleThis shows how the above two regexes (for matching email addresses and domains) might work:Note that it would be possible to adapt the above example to using `Regex` with an expression like:After a match, one could then inspect the capture groups to figure out which alternates matched. The problem is that it is hard to make this approach scale when there are many regexes since the overlap between each alternate isn't always obvious to reason about.LimitationsRegex sets are limited to answering the following two questions:Does any regex in the set match? If so, which regexes in the set match? As with the main `Regex` type, it is cheaper to ask (1) instead of (2) since the matching engines can stop after the first match is found.Other features like finding the location of successive matches or their sub-captures aren't supported. If you need this functionality, the recommended approach is to compile each regex in the set independently and selectively match them based on which regexes in the set matched.PerformanceA `RegexSet` has the same performance characteristics as `Regex`. Namely, search takes `O(mn)` time, where `m` is proportional to the size of the regex set and `n` is proportional to the length of the search text."],["RegexSplits","Yields all substrings delimited by a regular expression match.`'r` is the lifetime of the compiled regular expression and `'t` is the lifetime of the string being split."],["RegexSplitsN","Yields at most `N` substrings delimited by a regular expression match.The last substring will be whatever remains after splitting.`'r` is the lifetime of the compiled regular expression and `'t` is the lifetime of the string being split."],["SetMatches","A set of matches returned by a regex set."],["SetMatchesIntoIter","An owned iterator over the set of matches from a regex set."],["SetMatchesIter","A borrowed iterator over the set of matches from a regex set.The lifetime `'a` refers to the lifetime of a `SetMatches` value."],["SubCaptures","An iterator over capture groups for a particular match of a regular expression.`'c` is the lifetime of the captures."],["SubCapturesNamed","An Iterator over named capture groups as a tuple with the group name and the value.`'c` is the lifetime of the captures."],["SubCapturesPos","An iterator over capture group positions for a particular match of a regular expression.Positions are byte indices in terms of the original string matched.`'c` is the lifetime of the captures."]],"trait":[["Replacer","Replacer describes types that can be used to replace matches in a string."]]});