initSidebarItems({"struct":[["CaptureNames","An iterator over the names of all possible captures.`None` indicates an unnamed capture; the first element (capture 0, the whole matched region) is always unnamed.`'r` is the lifetime of the compiled regular expression."],["Captures","Captures represents a group of captured byte strings for a single match.The 0th capture always corresponds to the entire match. Each subsequent index corresponds to the next capture group in the regex. If a capture group is named, then the matched byte string is *also* available via the `name` method. (Note that the 0th capture is always unnamed and so must be accessed with the `at` method.)Positions returned from a capture group are always byte indices.`'t` is the lifetime of the matched text."],["FindCaptures","An iterator that yields all non-overlapping capture groups matching a particular regular expression.The iterator stops when no more matches can be found.`'r` is the lifetime of the compiled regular expression and `'t` is the lifetime of the matched byte string."],["FindMatches","An iterator over all non-overlapping matches for a particular string.The iterator yields a tuple of integers corresponding to the start and end of the match. The indices are byte offsets. The iterator stops when no more matches can be found.`'r` is the lifetime of the compiled regular expression and `'t` is the lifetime of the matched byte string."],["NoExpand","NoExpand indicates literal byte string replacement.It can be used with `replace` and `replace_all` to do a literal byte string replacement without expanding `$name` to their corresponding capture groups. This can be both convenient (to avoid escaping `$`, for example) and performant (since capture groups don't need to be found).`'t` is the lifetime of the literal text."],["Regex","A compiled regular expression for matching arbitrary bytes.It can be used to search, split or replace text. All searching is done with an implicit `.*?` at the beginning and end of an expression. To force an expression to match the whole string (or a prefix or a suffix), you must use an anchor like `^` or `$` (or `\\A` and `\\z`).Like the `Regex` type in the parent module, matches with this regex return byte offsets into the search text. **Unlike** the parent `Regex` type, these byte offsets may not correspond to UTF-8 sequence boundaries since the regexes in this module can match arbitrary bytes."],["RegexSet","Match multiple (possibly overlapping) regular expressions in a single scan.A regex set corresponds to the union of two or more regular expressions. That is, a regex set will match text where at least one of its constituent regular expressions matches. A regex set as its formulated here provides a touch more power: it will also report *which* regular expressions in the set match. Indeed, this is the key difference between regex sets and a single `Regex` with many alternates, since only one alternate can match at a time.For example, consider regular expressions to match email addresses and domains: `[a-z]+@[a-z]+.(com|org|net)` and `[a-z]+.(com|org|net)`. If a regex set is constructed from those regexes, then searching the text `foo@example.com` will report both regexes as matching. Of course, one could accomplish this by compiling each regex on its own and doing two searches over the text. The key advantage of using a regex set is that it will report the matching regexes using a *single pass through the text*. If one has hundreds or thousands of regexes to match repeatedly (like a URL router for a complex web application or a user agent matcher), then a regex set can realize huge performance gains.ExampleThis shows how the above two regexes (for matching email addresses and domains) might work:Note that it would be possible to adapt the above example to using `Regex` with an expression like:After a match, one could then inspect the capture groups to figure out which alternates matched. The problem is that it is hard to make this approach scale when there are many regexes since the overlap between each alternate isn't always obvious to reason about.LimitationsRegex sets are limited to answering the following two questions:Does any regex in the set match? If so, which regexes in the set match? As with the main `Regex` type, it is cheaper to ask (1) instead of (2) since the matching engines can stop after the first match is found.Other features like finding the location of successive matches or their sub-captures aren't supported. If you need this functionality, the recommended approach is to compile each regex in the set independently and selectively match them based on which regexes in the set matched.PerformanceA `RegexSet` has the same performance characteristics as `Regex`. Namely, search takes `O(mn)` time, where `m` is proportional to the size of the regex set and `n` is proportional to the length of the search text."],["SetMatches","A set of matches returned by a regex set."],["SetMatchesIntoIterBytes","An owned iterator over the set of matches from a regex set."],["SetMatchesIterBytes","A borrowed iterator over the set of matches from a regex set.The lifetime `'a` refers to the lifetime of a `SetMatches` value."],["Splits","Yields all substrings delimited by a regular expression match.`'r` is the lifetime of the compiled regular expression and `'t` is the lifetime of the byte string being split."],["SplitsN","Yields at most `N` substrings delimited by a regular expression match.The last substring will be whatever remains after splitting.`'r` is the lifetime of the compiled regular expression and `'t` is the lifetime of the byte string being split."],["SubCaptures","An iterator over capture groups for a particular match of a regular expression.`'c` is the lifetime of the captures and `'t` is the lifetime of the matched text."],["SubCapturesNamed","An Iterator over named capture groups as a tuple with the group name and the value.`'c` is the lifetime of the captures and `'t` is the lifetime of the matched text."],["SubCapturesPos","An iterator over capture group positions for a particular match of a regular expression.Positions are byte indices in terms of the original byte string matched.`'c` is the lifetime of the captures."]],"trait":[["Replacer","Replacer describes types that can be used to replace matches in a byte string.In general, users of this crate shouldn't need to implement this trait, since implementations are already provided for `&[u8]` and `FnMut(&Captures) -> Vec<u8>`, which covers most use cases."]]});