initSidebarItems({"constant":[["ALPN_PROTOCOLS","A set of protocol names that the library should use to indicate that HTTP/2 is supported during protocol negotiation (NPN or ALPN). We include some of the drafts' protocol names, since there is basically no difference for all intents and purposes (and some servers out there still only officially advertise draft support). TODO: Eventually only use \"h2\"."]],"enum":[["HttpError","An enum representing errors that can arise when performing operations involving an HTTP/2 connection."],["HttpScheme","An enum representing the two possible HTTP schemes."]],"mod":[["client","The module contains a number of reusable components for implementing the client side of an HTTP/2 connection."],["connection","The module contains the implementation of an HTTP/2 connection.This provides an API to read and write raw HTTP/2 frames, as well as a way to hook into higher-level events arising on an HTTP/2 connection, such as the receipt of headers on a particular stream or a new data chunk.The `SendFrame` and `ReceiveFrame` traits are the API to sending and receiving frames off of an HTTP/2 connection. The module includes default implementations of those traits for `io::Write` and `solicit::http::transport::TransportStream` types.The `HttpConnection` struct builds on top of these traits and provides an API for sending messages of a higher level to the peer (such as writing data or headers, while automatically handling the framing and header encoding), as well as for handling incoming events of that type. The `Session` trait is the bridge between the connection layer (i.e. the `HttpConnection`) and the higher layers that handle these events and pass them on to the application."],["frame","The module contains the implementation of HTTP/2 frames."],["priority","The module exposes an API for defining data prioritization strategies.Types that implement the `DataPrioritizer` trait can be used to provide new data for an `HttpConnection` to send to its peer. Neither the `HttpConnection` nor the `DataPrioritizer` have control over exactly *when* the data is sent. This is left up to the particular client implementations to trigger."],["server","The module contains a number of reusable components for implementing the server side of an HTTP/2 connection."],["session","Defines the interface for the session-level management of HTTP/2 communication. This is effectively an API that allows hooking into an HTTP/2 connection in order to handle events arising on the connection.The module also provides a default implementation for some of the traits."],["transport","The module contains implementations of the transport layer functionality that HTTP/2 requires. It exposes APIs that allow the HTTP/2 connection to use the transport layer without requiring it to know which exact implementation they are using (e.g. a clear-text TCP connection, a TLS protected connection, or even a mock implementation).The types provided here are purely for convenience in being able to easily plug in the native Rust socket IO primitives into the HTTP/2 connection API without having to write too much boilerplate around them."]],"struct":[["Request","A struct representing a full HTTP/2 request, along with the full body, as a sequence of bytes."],["Response","A struct representing the full raw response received on an HTTP/2 connection.The full body of the response is included, regardless how large it may be. The headers contain both the meta-headers, as well as the actual headers."]],"type":[["Header","An alias for the type that represents HTTP/2 headers. For now we only alias the tuple of byte vectors instead of going with a full struct representation."],["HttpResult","A convenience `Result` type that has the `HttpError` type as the error type and a generic Ok result type."],["StreamId","An alias for the type that represents the ID of an HTTP/2 stream"]]});